<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>蒲丰投针实验模拟器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#FF7D00',
                        neutral: '#F5F7FA',
                        dark: '#1D2129',
                    },
                    fontFamily: {
                        inter: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .transition-all-300 {
                transition: all 300ms ease-in-out;
            }
            .shadow-soft {
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            }
        }
    </style>
</head>
<body class="font-inter bg-neutral min-h-screen text-dark">
    <!-- 顶部导航 -->
    <header class="bg-white shadow-md sticky top-0 z-50 transition-all duration-300">
        <div class="container mx-auto px-4 py-4 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fa fa-calculator text-primary text-2xl"></i>
                <h1 class="text-[clamp(1.2rem,3vw,1.8rem)] font-bold text-primary">蒲丰投针实验模拟器</h1>
            </div>
            <nav class="hidden md:flex">
                <ul class="flex space-x-6">
                    <li><a href="#about" class="hover:text-primary transition-all-300"><i class="fa fa-info-circle mr-1"></i>关于实验</a></li>
                    <li><a href="#simulator" class="hover:text-primary transition-all-300"><i class="fa fa-flask mr-1"></i>开始实验</a></li>
                    <li><a href="#explanation" class="hover:text-primary transition-all-300"><i class="fa fa-lightbulb-o mr-1"></i>原理说明</a></li>
                </ul>
            </nav>
            <button class="md:hidden text-primary text-xl" id="mobileMenuBtn">
                <i class="fa fa-bars"></i>
            </button>
        </div>
        <!-- 移动端菜单 -->
        <div id="mobileMenu" class="hidden md:hidden bg-white border-t">
            <div class="container mx-auto px-4 py-2">
                <ul class="space-y-3 py-2">
                    <li><a href="#about" class="block hover:text-primary transition-all-300"><i class="fa fa-info-circle mr-1"></i>关于实验</a></li>
                    <li><a href="#simulator" class="block hover:text-primary transition-all-300"><i class="fa fa-flask mr-1"></i>开始实验</a></li>
                    <li><a href="#explanation" class="block hover:text-primary transition-all-300"><i class="fa fa-lightbulb-o mr-1"></i>原理说明</a></li>
                </ul>
            </div>
        </div>
    </header>

    <!-- 主内容区 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 介绍部分 -->
        <section id="about" class="mb-12 bg-white rounded-xl p-6 shadow-soft">
            <h2 class="text-2xl font-bold mb-4 text-primary">关于蒲丰投针实验</h2>
            <p class="mb-4">蒲丰投针实验是18世纪法国数学家乔治-路易·勒克莱尔， comte de Buffon设计的一种计算圆周率π的概率方法。</p>
            <p class="mb-4">实验过程：在平面上画有一组间距为d的平行线，将一根长度为l（l &lt; d）的针任意投掷到这个平面上，记录针与平行线相交的次数。</p>
            <p>通过公式 <span class="font-mono bg-gray-100 px-2 py-1 rounded">P = 2l/(πd)</span> 可以推导出 <span class="font-mono bg-gray-100 px-2 py-1 rounded">π ≈ 2lN/(dK)</span>，其中N是投针总次数，K是相交次数。</p>
        </section>

        <!-- 模拟器部分 -->
        <section id="simulator" class="mb-12">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- 控制面板 -->
                <div class="bg-white rounded-xl p-6 shadow-soft lg:col-span-1">
                    <h2 class="text-2xl font-bold mb-6 text-primary flex items-center">
                        <i class="fa fa-sliders mr-2"></i>实验控制
                    </h2>
                    
                    <!-- 参数设置 -->
                    <div class="mb-8">
                        <h3 class="text-lg font-semibold mb-4 pb-2 border-b border-gray-200">参数设置</h3>
                        
                        <div class="mb-4">
                            <label for="needleLength" class="block text-sm font-medium mb-1">针长度 (l)</label>
                            <div class="flex items-center">
                                <input type="range" id="needleLength" min="1" max="9" value="5" 
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                                <span id="needleLengthValue" class="ml-3 min-w-[30px] text-center font-medium">5</span>
                            </div>
                        </div>
                        
                        <div class="mb-4">
                            <label for="lineDistance" class="block text-sm font-medium mb-1">线间距 (d)</label>
                            <div class="flex items-center">
                                <input type="range" id="lineDistance" min="2" max="10" value="10" 
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                                <span id="lineDistanceValue" class="ml-3 min-w-[30px] text-center font-medium">10</span>
                            </div>
                        </div>
                        
                        <div class="mb-4">
                            <label for="throwCount" class="block text-sm font-medium mb-1">每次投掷数量</label>
                            <div class="flex items-center">
                                <input type="range" id="throwCount" min="1" max="1000" value="1" step="1"
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                                <span id="throwCountValue" class="ml-3 min-w-[50px] text-center font-medium">1</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 控制按钮 -->
                    <div class="flex flex-col space-y-3 mb-8">
                        <button id="throwOnce" class="bg-primary hover:bg-primary/90 text-white py-3 px-4 rounded-lg transition-all-300 flex items-center justify-center">
                            <i class="fa fa-play mr-2"></i>投掷一次
                        </button>
                        <button id="throwMultiple" class="bg-secondary hover:bg-secondary/90 text-white py-3 px-4 rounded-lg transition-all-300 flex items-center justify-center">
                            <i class="fa fa-repeat mr-2"></i>连续投掷
                        </button>
                        <button id="resetExperiment" class="bg-gray-200 hover:bg-gray-300 text-gray-700 py-3 px-4 rounded-lg transition-all-300 flex items-center justify-center">
                            <i class="fa fa-refresh mr-2"></i>重置实验
                        </button>
                    </div>
                    
                    <!-- 实验数据 -->
                    <div class="bg-gray-50 rounded-lg p-4">
                        <h3 class="text-lg font-semibold mb-4 pb-2 border-b border-gray-200">实验数据</h3>
                        
                        <div class="space-y-3">
                            <div class="flex justify-between">
                                <span class="text-gray-600">总投掷次数:</span>
                                <span id="totalThrows" class="font-bold">0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-600">相交次数:</span>
                                <span id="intersectionCount" class="font-bold">0</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-600">相交概率:</span>
                                <span id="probability" class="font-bold">0</span>
                            </div>
                            <div class="flex justify-between pt-2 border-t border-gray-200 mt-2">
                                <span class="text-gray-600">估算π值:</span>
                                <span id="piEstimate" class="font-bold text-primary">0</span>
                            </div>
                            <div class="flex justify-between text-sm text-gray-500">
                                <span>实际π值:</span>
                                <span>3.1415926535</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 模拟区域和图表 -->
                <div class="lg:col-span-2 space-y-6">
                    <!-- 模拟区域 -->
                    <div class="bg-white rounded-xl p-4 shadow-soft">
                        <h3 class="text-lg font-semibold mb-3">模拟区域</h3>
                        <div class="relative bg-gray-50 rounded-lg overflow-hidden border border-gray-200" style="height: 400px;">
                            <canvas id="simulationCanvas" class="w-full h-full"></canvas>
                            <div id="loadingIndicator" class="absolute inset-0 flex items-center justify-center bg-white/80 z-10 hidden">
                                <div class="flex flex-col items-center">
                                    <div class="w-12 h-12 border-4 border-primary border-t-transparent rounded-full animate-spin"></div>
                                    <p class="mt-2 text-primary font-medium">模拟中...</p>
                                </div>
                            </div>
                            <div id="initialMessage" class="absolute inset-0 flex items-center justify-center z-0">
                                <p class="text-gray-400 text-center px-4">点击"投掷一次"或"连续投掷"开始实验</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 图表展示 -->
                    <div class="bg-white rounded-xl p-4 shadow-soft">
                        <h3 class="text-lg font-semibold mb-3">π值估算趋势</h3>
                        <div class="bg-gray-50 rounded-lg p-2" style="height: 320px;">
                            <canvas id="piChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- 原理说明 -->
        <section id="explanation" class="mb-12 bg-white rounded-xl p-6 shadow-soft">
            <h2 class="text-2xl font-bold mb-4 text-primary">实验原理</h2>
            
            <div class="prose max-w-none">
                <p class="mb-4">蒲丰投针实验的核心是通过概率计算来估算π值。其数学原理如下：</p>
                
                <div class="bg-gray-50 p-4 rounded-lg mb-4">
                    <p class="font-medium mb-2">假设：</p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>平行线之间的距离为d</li>
                        <li>针的长度为l（l &lt; d）</li>
                        <li>针的中点到最近一条平行线的距离为x（0 ≤ x ≤ d/2）</li>
                        <li>针与平行线的夹角为θ（0 ≤ θ ≤ π/2）</li>
                    </ul>
                </div>
                
                <p class="mb-4">当满足条件 <span class="font-mono bg-gray-100 px-1">x ≤ (l/2)·sinθ</span> 时，针会与平行线相交。</p>
                
                <p class="mb-4">通过积分计算，针与平行线相交的概率为：</p>
                <div class="text-center my-4">
                    <p class="font-mono bg-gray-100 px-2 py-1 inline-block">P = 2l/(πd)</p>
                </div>
                
                <p class="mb-4">通过实验得到频率来近似概率P ≈ K/N（K为相交次数，N为总投掷次数），可以推导出：</p>
                <div class="text-center my-4">
                    <p class="font-mono bg-gray-100 px-2 py-1 inline-block">π ≈ 2lN/(dK)</p>
                </div>
                
                <p>随着投掷次数的增加，估算的π值会越来越接近真实值。</p>
            </div>
        </section>
    </main>

    <!-- 页脚 -->
    <footer class="bg-dark text-white py-8">
        <div class="container mx-auto px-4">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="mb-4 md:mb-0">
                    <p class="text-gray-400">© 2023 蒲丰投针实验模拟器 | 概率统计教学工具</p>
                </div>
                <div class="flex space-x-4">
                    <a href="#" class="text-gray-400 hover:text-white transition-all-300"><i class="fa fa-github text-xl"></i></a>
                    <a href="#" class="text-gray-400 hover:text-white transition-all-300"><i class="fa fa-twitter text-xl"></i></a>
                    <a href="#" class="text-gray-400 hover:text-white transition-all-300"><i class="fa fa-envelope text-xl"></i></a>
                </div>
            </div>
        </div>
    </footer>

    <script>
        // 等待DOM加载完成
        document.addEventListener('DOMContentLoaded', () => {
            // 获取DOM元素
            const canvas = document.getElementById('simulationCanvas');
            const ctx = canvas.getContext('2d');
            const needleLengthSlider = document.getElementById('needleLength');
            const needleLengthValue = document.getElementById('needleLengthValue');
            const lineDistanceSlider = document.getElementById('lineDistance');
            const lineDistanceValue = document.getElementById('lineDistanceValue');
            const throwCountSlider = document.getElementById('throwCount');
            const throwCountValue = document.getElementById('throwCountValue');
            const throwOnceBtn = document.getElementById('throwOnce');
            const throwMultipleBtn = document.getElementById('throwMultiple');
            const resetBtn = document.getElementById('resetExperiment');
            const totalThrowsEl = document.getElementById('totalThrows');
            const intersectionCountEl = document.getElementById('intersectionCount');
            const probabilityEl = document.getElementById('probability');
            const piEstimateEl = document.getElementById('piEstimate');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const initialMessage = document.getElementById('initialMessage');
            const mobileMenuBtn = document.getElementById('mobileMenuBtn');
            const mobileMenu = document.getElementById('mobileMenu');
            
            // 实验参数和状态
            let needleLength = parseInt(needleLengthSlider.value);
            let lineDistance = parseInt(lineDistanceSlider.value);
            let throwCount = parseInt(throwCountSlider.value);
            let totalThrows = 0;
            let intersectionCount = 0;
            let needles = [];
            let isThrowing = false;
            let piHistory = [];
            
            // 移动端菜单切换
            mobileMenuBtn.addEventListener('click', () => {
                mobileMenu.classList.toggle('hidden');
            });
            
            // 平滑滚动
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetElement = document.querySelector(targetId);
                    
                    if (targetElement) {
                        window.scrollTo({
                            top: targetElement.offsetTop - 80,
                            behavior: 'smooth'
                        });
                        
                        // 关闭移动菜单
                        if (!mobileMenu.classList.contains('hidden')) {
                            mobileMenu.classList.add('hidden');
                        }
                    }
                });
            });
            
            // 设置Canvas尺寸 - 修复响应式问题的核心部分
            function resizeCanvas() {
                if (!canvas) return;
                
                const container = canvas.parentElement;
                if (!container) return;
                
                // 获取容器的计算样式
                const containerStyle = getComputedStyle(container);
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                // 考虑容器的内边距
                const paddingLeft = parseFloat(containerStyle.paddingLeft);
                const paddingRight = parseFloat(containerStyle.paddingRight);
                const paddingTop = parseFloat(containerStyle.paddingTop);
                const paddingBottom = parseFloat(containerStyle.paddingBottom);
                
                // 计算可用宽度和高度
                const availableWidth = width - paddingLeft - paddingRight;
                const availableHeight = height - paddingTop - paddingBottom;
                
                // 设置Canvas的实际尺寸
                canvas.width = availableWidth;
                canvas.height = availableHeight;
                
                // 设置Canvas的CSS尺寸，确保显示正确
                canvas.style.width = `${availableWidth}px`;
                canvas.style.height = `${availableHeight}px`;
                
                // 重新绘制场景
                drawScene();
            }
            
            // 初始化时调整一次尺寸，并监听窗口大小变化
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 初始化π值趋势图
            const piChartCtx = document.getElementById('piChart').getContext('2d');
            const piChart = new Chart(piChartCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '估算π值',
                        data: [],
                        borderColor: '#165DFF',
                        backgroundColor: 'rgba(22, 93, 255, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.4,
                        fill: true
                    }, {
                        label: '实际π值',
                        data: [],
                        borderColor: '#FF7D00',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        tension: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: 2,
                            max: 4,
                            title: {
                                display: true,
                                text: 'π值'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '投掷次数'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    animation: false
                }
            });
            
            // 更新滑块显示值
            needleLengthSlider.addEventListener('input', () => {
                needleLength = parseInt(needleLengthSlider.value);
                needleLengthValue.textContent = needleLength;
            });
            
            lineDistanceSlider.addEventListener('input', () => {
                lineDistance = parseInt(lineDistanceSlider.value);
                lineDistanceValue.textContent = lineDistance;
            });
            
            throwCountSlider.addEventListener('input', () => {
                throwCount = parseInt(throwCountSlider.value);
                throwCountValue.textContent = throwCount;
            });
            
            // 绘制场景（平行线和所有针）
            function drawScene() {
                if (!ctx) return;
                
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制平行线
                ctx.strokeStyle = '#CBD5E1';
                ctx.lineWidth = 1;
                
                // 计算需要绘制的线条数量
                const linesCount = Math.ceil(canvas.height / lineDistance) + 1;
                for (let i = 0; i < linesCount; i++) {
                    const y = i * lineDistance;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // 绘制针
                needles.forEach(needle => {
                    ctx.beginPath();
                    ctx.moveTo(needle.x1, needle.y1);
                    ctx.lineTo(needle.x2, needle.y2);
                    ctx.strokeStyle = needle.intersected ? '#FF7D00' : '#165DFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // 根据是否有针显示初始信息
                if (needles.length === 0) {
                    initialMessage.classList.remove('hidden');
                } else {
                    initialMessage.classList.add('hidden');
                }
            }
            
            // 投掷一根针
            function throwNeedle() {
                if (!canvas) return null;
                
                // 随机生成针的中点位置
                const centerX = Math.random() * canvas.width;
                const centerY = Math.random() * canvas.height;
                
                // 随机生成针与水平线的夹角（弧度）
                const angle = Math.random() * Math.PI;
                
                // 计算针的两个端点
                const halfLength = needleLength / 2;
                const x1 = centerX - halfLength * Math.cos(angle);
                const y1 = centerY - halfLength * Math.sin(angle);
                const x2 = centerX + halfLength * Math.cos(angle);
                const y2 = centerY + halfLength * Math.sin(angle);
                
                // 检查是否与平行线相交
                const intersected = checkIntersection(y1, y2);
                
                // 记录针的信息
                const needle = { x1, y1, x2, y2, intersected };
                needles.push(needle);
                
                // 更新统计数据
                totalThrows++;
                if (intersected) {
                    intersectionCount++;
                }
                
                return needle;
            }
            
            // 检查针是否与任何平行线相交
            function checkIntersection(y1, y2) {
                // 确保y1 <= y2以便简化计算
                if (y1 > y2) {
                    [y1, y2] = [y2, y1];
                }
                
                // 找到y1下方最近的平行线
                const nearestLineBelow = Math.floor(y1 / lineDistance) * lineDistance;
                
                // 检查从最近的线开始，是否有任何线穿过针
                for (let y = nearestLineBelow; y <= y2; y += lineDistance) {
                    if (y >= y1 && y <= y2) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // 更新统计信息显示
            function updateStats() {
                totalThrowsEl.textContent = totalThrows;
                intersectionCountEl.textContent = intersectionCount;
                
                // 计算概率和估算的π值
                const probability = totalThrows > 0 ? (intersectionCount / totalThrows).toFixed(6) : '0';
                let piEstimate = 0;
                
                if (intersectionCount > 0) {
                    piEstimate = (2 * needleLength * totalThrows) / (lineDistance * intersectionCount);
                    piEstimate = piEstimate.toFixed(6);
                    
                    // 记录π值历史，用于图表展示
                    if (totalThrows % 10 === 0 || totalThrows < 100) {
                        piHistory.push({
                            throws: totalThrows,
                            pi: parseFloat(piEstimate)
                        });
                        
                        // 更新图表
                        updatePiChart();
                    }
                }
                
                probabilityEl.textContent = probability;
                piEstimateEl.textContent = piEstimate;
            }
            
            // 更新π值趋势图
            function updatePiChart() {
                // 限制数据点数量，保持图表性能
                const maxDataPoints = 1000;
                const displayData = piHistory.slice(-maxDataPoints);
                
                piChart.data.labels = displayData.map(item => item.throws);
                piChart.data.datasets[0].data = displayData.map(item => item.pi);
                piChart.data.datasets[1].data = displayData.map(() => Math.PI);
                
                piChart.update();
            }
            
            // 投掷多次针（带动画）
            async function throwNeedles(count, animate = true) {
                if (isThrowing) return;
                
                isThrowing = true;
                throwOnceBtn.disabled = true;
                throwMultipleBtn.disabled = true;
                needleLengthSlider.disabled = true;
                lineDistanceSlider.disabled = true;
                throwCountSlider.disabled = true;
                
                // 对于大量投掷，显示加载指示器
                if (count > 100) {
                    loadingIndicator.classList.remove('hidden');
                }
                
                // 分批次投掷，避免浏览器卡顿
                const batchSize = animate ? 10 : 1000;
                let remaining = count;
                
                try {
                    while (remaining > 0) {
                        const batch = Math.min(remaining, batchSize);
                        
                        for (let i = 0; i < batch; i++) {
                            throwNeedle();
                        }
                        
                        // 更新显示
                        updateStats();
                        
                        // 如果需要动画效果，绘制并短暂等待
                        if (animate) {
                            drawScene();
                            // 使用requestAnimationFrame确保平滑动画
                            await new Promise(resolve => requestAnimationFrame(() => 
                                setTimeout(resolve, 10)
                            ));
                        }
                        
                        remaining -= batch;
                    }
                } catch (error) {
                    console.error("投掷过程中出错:", error);
                } finally {
                    // 最后绘制一次完整场景
                    drawScene();
                    
                    // 隐藏加载指示器
                    loadingIndicator.classList.add('hidden');
                    
                    isThrowing = false;
                    throwOnceBtn.disabled = false;
                    throwMultipleBtn.disabled = false;
                    needleLengthSlider.disabled = false;
                    lineDistanceSlider.disabled = false;
                    throwCountSlider.disabled = false;
                }
            }
            
            // 重置实验
            function resetExperiment() {
                if (isThrowing) return;
                
                needles = [];
                totalThrows = 0;
                intersectionCount = 0;
                piHistory = [];
                
                updateStats();
                drawScene();
                
                // 重置图表
                piChart.data.labels = [];
                piChart.data.datasets[0].data = [];
                piChart.data.datasets[1].data = [];
                piChart.update();
            }
            
            // 绑定事件监听器
            throwOnceBtn.addEventListener('click', () => {
                throwNeedles(throwCount, true);
            });
            
            throwMultipleBtn.addEventListener('click', () => {
                // 连续投掷10000次，不显示每个针的动画以提高性能
                throwNeedles(10000, false);
            });
            
            resetBtn.addEventListener('click', resetExperiment);
            
            // 初始绘制
            drawScene();
            
            // 窗口大小变化时重新绘制
            window.addEventListener('resize', drawScene);
        });
    </script>
</body>
</html>
